
/home/tony/Desktop/uboot-2015-dev/build/board/amlogic/gxl_p212_v1/firmware/bl21.elf:     file format elf64-littleaarch64
/home/tony/Desktop/uboot-2015-dev/build/board/amlogic/gxl_p212_v1/firmware/bl21.elf
architecture: aarch64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000d900b400

Program Header:
    LOAD off    0x0000000000000000 vaddr 0x00000000d9000000 paddr 0x00000000d9000000 align 2**16
         filesz 0x000000000000b858 memsz 0x000000000000b858 flags r-x
private flags = 0:

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 ro            00000458  00000000d900b400  00000000d900b400  0000b400  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .debug_info   00000661  0000000000000000  0000000000000000  0000b858  2**0
                  CONTENTS, READONLY, DEBUGGING
  2 .debug_abbrev 00000261  0000000000000000  0000000000000000  0000beb9  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_loc    000004d4  0000000000000000  0000000000000000  0000c11a  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_aranges 00000150  0000000000000000  0000000000000000  0000c5f0  2**4
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_ranges 00000100  0000000000000000  0000000000000000  0000c740  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000002e1  0000000000000000  0000000000000000  0000c840  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    00000258  0000000000000000  0000000000000000  0000cb21  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .comment      0000005f  0000000000000000  0000000000000000  0000cd79  2**0
                  CONTENTS, READONLY
  9 .debug_frame  000001e0  0000000000000000  0000000000000000  0000cdd8  2**3
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000d900b400 l    d  ro	0000000000000000 ro
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_loc	0000000000000000 .debug_loc
0000000000000000 l    d  .debug_aranges	0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_ranges	0000000000000000 .debug_ranges
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 l    d  .debug_frame	0000000000000000 .debug_frame
0000000000000000 l    df *ABS*	0000000000000000 /home/tony/Desktop/uboot-2015-dev/build/board/amlogic/gxl_p212_v1/firmware/bl21_entrypoint.o
00000000d900b40c l       ro	0000000000000000 z_loop16
00000000d900b420 l       ro	0000000000000000 z_loop1
00000000d900b430 l       ro	0000000000000000 z_end
0000000000000000 l    df *ABS*	0000000000000000 bl21_main.c
00000000d900b750 l     O ro	00000000000000e8 pwm_voltage_table
0000000000000000 l    df *ABS*	0000000000000000 serial.c
0000000000000000 l    df *ABS*	0000000000000000 
0000000000000000 l       *UND*	0000000000000000 zeromem16
00000000d900b6e8 g     F ro	0000000000000068 serial_put_dec
00000000d900b858 g       ro	0000000000000000 __DATA_START__
00000000d900b66c g     F ro	0000000000000004 bl21_main
0000000000000000 g       *ABS*	0000000000000000 __BSS_SIZE__
00000000d900b448 g     F ro	0000000000000028 _udelay_
00000000d900b5e8 g     F ro	000000000000007c power_init
00000000d900b858 g       ro	0000000000000000 __RO_END_UNALIGNED__
00000000d900b470 g     F ro	00000000000000f8 pwm_init
00000000d900b670 g     F ro	0000000000000048 serial_putc
00000000d900b858 g       ro	0000000000000000 __DATA_END__
00000000d900b860 g       ro	0000000000000000 __BSS_END__
00000000d900b664 g     F ro	0000000000000008 board_init
00000000d900b6b8 g     F ro	0000000000000030 serial_puts
00000000d900b858 g       ro	0000000000000000 __RO_END__
00000000d900b860 g       ro	0000000000000000 __BSS_START__
00000000d900b400 g       ro	0000000000000000 __RO_START__
00000000d900b568 g     F ro	0000000000000080 pwm_set_voltage
00000000d900b400 g       ro	0000000000000000 bl21_entrypoint



Disassembly of section ro:

00000000d900b400 <__RO_START__>:
	 * Zero out NOBITS sections. There are 2 of them:
	 *   - the .bss section;
	 *   - the coherent memory section.
	 * ---------------------------------------------
	 */
	ldr	x0, =__BSS_START__
    d900b400:	580001c0 	ldr	x0, d900b438 <z_end+0x8>
	ldr	x1, =__BSS_SIZE__
    d900b404:	580001e1 	ldr	x1, d900b440 <z_end+0x10>

	add	x2, x0, x1
    d900b408:	8b010002 	add	x2, x0, x1

00000000d900b40c <z_loop16>:
/* zero 16 bytes at a time */
z_loop16:
	sub	x3, x2, x0
    d900b40c:	cb000043 	sub	x3, x2, x0
	cmp	x3, #16
    d900b410:	f100407f 	cmp	x3, #0x10
	b.lt	z_loop1
    d900b414:	5400006b 	b.lt	d900b420 <z_loop1>
	stp	xzr, xzr, [x0], #16
    d900b418:	a8817c1f 	stp	xzr, xzr, [x0],#16
	b	z_loop16
    d900b41c:	17fffffc 	b	d900b40c <z_loop16>

00000000d900b420 <z_loop1>:
/* zero byte per byte */
z_loop1:
	cmp	x0, x2
    d900b420:	eb02001f 	cmp	x0, x2
	b.eq	z_end
    d900b424:	54000060 	b.eq	d900b430 <z_end>
	strb	wzr, [x0], #1
    d900b428:	3800141f 	strb	wzr, [x0],#1
	b	z_loop1
    d900b42c:	17fffffd 	b	d900b420 <z_loop1>

00000000d900b430 <z_end>:

	/* ---------------------------------------------
	 * Jump to main function.
	 * ---------------------------------------------
	 */
	b	bl21_main
    d900b430:	1400008f 	b	d900b66c <bl21_main>
    d900b434:	00000000 	.word	0x00000000
    d900b438:	d900b860 	.word	0xd900b860
	...

00000000d900b448 <_udelay_>:
    pwm_f,
};

unsigned int _get_time(void)
{
	return P_EE_TIMER_E;
    d900b448:	d2933101 	mov	x1, #0x9988                	// #39304
    d900b44c:	f2b82201 	movk	x1, #0xc110, lsl #16
    d900b450:	b9400022 	ldr	w2, [x1]
    d900b454:	d2933101 	mov	x1, #0x9988                	// #39304
    d900b458:	f2b82201 	movk	x1, #0xc110, lsl #16
    d900b45c:	b9400021 	ldr	w1, [x1]

void _udelay_(unsigned int us)
{
	unsigned int t0 = _get_time();

	while (_get_time() - t0 <= us)
    d900b460:	4b020021 	sub	w1, w1, w2
    d900b464:	6b00003f 	cmp	w1, w0
    d900b468:	54ffff69 	b.ls	d900b454 <_udelay_+0xc>
		;
}
    d900b46c:	d65f03c0 	ret

00000000d900b470 <pwm_init>:
	/*
	 * TODO: support more pwm controllers, right now only support
	 * PWM_B, PWM_D
	 */

	switch (id) {
    d900b470:	7100041f 	cmp	w0, #0x1
    d900b474:	540003c0 	b.eq	d900b4ec <pwm_init+0x7c>
    d900b478:	71000c1f 	cmp	w0, #0x3
    d900b47c:	54000721 	b.ne	d900b560 <pwm_init+0xf0>
		reg |=  (1 << 11);		// enable PWM_B
		P_PIN_MUX_REG2 = reg;
		break;

	case pwm_d:
		reg = P_PWM_MISC_REG_CD;
    d900b480:	d290c900 	mov	x0, #0x8648                	// #34376
    d900b484:	f2b82200 	movk	x0, #0xc110, lsl #16
    d900b488:	b9400001 	ldr	w1, [x0]
		reg &= ~(0x7f << 16);
		reg |=  ((1 << 23) | (1 << 1));
    d900b48c:	52800040 	mov	w0, #0x2                   	// #2
    d900b490:	72a01000 	movk	w0, #0x80, lsl #16
		P_PIN_MUX_REG2 = reg;
		break;

	case pwm_d:
		reg = P_PWM_MISC_REG_CD;
		reg &= ~(0x7f << 16);
    d900b494:	12096021 	and	w1, w1, #0xff80ffff
		reg |=  ((1 << 23) | (1 << 1));
    d900b498:	2a000021 	orr	w1, w1, w0
		P_PWM_MISC_REG_CD = reg;
    d900b49c:	d290c900 	mov	x0, #0x8648                	// #34376
    d900b4a0:	f2b82200 	movk	x0, #0xc110, lsl #16
    d900b4a4:	b9000001 	str	w1, [x0]
		/*
		 * default set to max voltage
		 */
		P_PWM_PWM_D = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
    d900b4a8:	d290c880 	mov	x0, #0x8644                	// #34372
    d900b4ac:	f2b82200 	movk	x0, #0xc110, lsl #16
    d900b4b0:	52800381 	mov	w1, #0x1c                  	// #28
    d900b4b4:	b9000001 	str	w1, [x0]
		reg  = P_PIN_MUX_REG1;
    d900b4b8:	d2889680 	mov	x0, #0x44b4                	// #17588
    d900b4bc:	f2bb5060 	movk	x0, #0xda83, lsl #16
    d900b4c0:	b9400001 	ldr	w1, [x0]
		reg &= ~(1 << 9);
		reg &= ~(1 << 11);
    d900b4c4:	12814000 	mov	w0, #0xfffff5ff            	// #-2561
    d900b4c8:	0a000021 	and	w1, w1, w0
		P_PIN_MUX_REG1 = reg;
    d900b4cc:	d2889680 	mov	x0, #0x44b4                	// #17588
    d900b4d0:	f2bb5060 	movk	x0, #0xda83, lsl #16
    d900b4d4:	b9000001 	str	w1, [x0]

		reg  = P_PIN_MUX_REG2;
    d900b4d8:	d2889700 	mov	x0, #0x44b8                	// #17592
    d900b4dc:	f2bb5060 	movk	x0, #0xda83, lsl #16
    d900b4e0:	b9400001 	ldr	w1, [x0]
		reg |=  (1 << 12);		// enable PWM_D
    d900b4e4:	32140021 	orr	w1, w1, #0x1000
    d900b4e8:	1400001b 	b	d900b554 <pwm_init+0xe4>
	 * PWM_B, PWM_D
	 */

	switch (id) {
	case pwm_b:
		reg = P_PWM_MISC_REG_AB;
    d900b4ec:	d290ab00 	mov	x0, #0x8558                	// #34136
    d900b4f0:	f2b82200 	movk	x0, #0xc110, lsl #16
    d900b4f4:	b9400001 	ldr	w1, [x0]
		reg &= ~(0x7f << 16);
		reg |=  ((1 << 23) | (1 << 1));
    d900b4f8:	52800040 	mov	w0, #0x2                   	// #2
    d900b4fc:	72a01000 	movk	w0, #0x80, lsl #16
	 */

	switch (id) {
	case pwm_b:
		reg = P_PWM_MISC_REG_AB;
		reg &= ~(0x7f << 16);
    d900b500:	12096021 	and	w1, w1, #0xff80ffff
		reg |=  ((1 << 23) | (1 << 1));
    d900b504:	2a000021 	orr	w1, w1, w0
		P_PWM_MISC_REG_AB = reg;
    d900b508:	d290ab00 	mov	x0, #0x8558                	// #34136
    d900b50c:	f2b82200 	movk	x0, #0xc110, lsl #16
    d900b510:	b9000001 	str	w1, [x0]
		/*
		 * default set to max voltage
		 */
		P_PWM_PWM_B = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
    d900b514:	d290aa80 	mov	x0, #0x8554                	// #34132
    d900b518:	f2b82200 	movk	x0, #0xc110, lsl #16
    d900b51c:	52800381 	mov	w1, #0x1c                  	// #28
    d900b520:	b9000001 	str	w1, [x0]
		reg  = P_PIN_MUX_REG1;
    d900b524:	d2889680 	mov	x0, #0x44b4                	// #17588
    d900b528:	f2bb5060 	movk	x0, #0xda83, lsl #16
    d900b52c:	b9400001 	ldr	w1, [x0]
		reg &= ~(1 << 10);
		P_PIN_MUX_REG1 = reg;
    d900b530:	d2889680 	mov	x0, #0x44b4                	// #17588
		/*
		 * default set to max voltage
		 */
		P_PWM_PWM_B = pwm_voltage_table[ARRAY_SIZE(pwm_voltage_table) - 1][0];
		reg  = P_PIN_MUX_REG1;
		reg &= ~(1 << 10);
    d900b534:	12157821 	and	w1, w1, #0xfffffbff
		P_PIN_MUX_REG1 = reg;
    d900b538:	f2bb5060 	movk	x0, #0xda83, lsl #16
    d900b53c:	b9000001 	str	w1, [x0]

		reg  = P_PIN_MUX_REG2;
    d900b540:	d2889700 	mov	x0, #0x44b8                	// #17592
    d900b544:	f2bb5060 	movk	x0, #0xda83, lsl #16
    d900b548:	b9400001 	ldr	w1, [x0]
		reg &= ~(1 << 5);
    d900b54c:	121a7821 	and	w1, w1, #0xffffffdf
		reg |=  (1 << 11);		// enable PWM_B
    d900b550:	32150021 	orr	w1, w1, #0x800
		reg &= ~(1 << 11);
		P_PIN_MUX_REG1 = reg;

		reg  = P_PIN_MUX_REG2;
		reg |=  (1 << 12);		// enable PWM_D
		P_PIN_MUX_REG2 = reg;
    d900b554:	d2889700 	mov	x0, #0x44b8                	// #17592
    d900b558:	f2bb5060 	movk	x0, #0xda83, lsl #16
    d900b55c:	b9000001 	str	w1, [x0]
		break;
	default:
		break;
	}

	_udelay_(200);
    d900b560:	52801900 	mov	w0, #0xc8                  	// #200
    d900b564:	17ffffb9 	b	d900b448 <_udelay_>

00000000d900b568 <pwm_set_voltage>:
}

void pwm_set_voltage(unsigned int id, unsigned int voltage)
{
    d900b568:	90000004 	adrp	x4, d900b000 <__BSS_SIZE__+0xd900b000>
	int to;

	for (to = 0; to < ARRAY_SIZE(pwm_voltage_table); to++) {
    d900b56c:	d2800002 	mov	x2, #0x0                   	// #0
    d900b570:	911d4084 	add	x4, x4, #0x750
    d900b574:	f100745f 	cmp	x2, #0x1d
    d900b578:	2a0203e3 	mov	w3, w2
    d900b57c:	540000e0 	b.eq	d900b598 <pwm_set_voltage+0x30>
    d900b580:	8b020c85 	add	x5, x4, x2, lsl #3
		if (pwm_voltage_table[to][1] >= voltage) {
    d900b584:	b94004a5 	ldr	w5, [x5,#4]
    d900b588:	91000442 	add	x2, x2, #0x1
    d900b58c:	6b0100bf 	cmp	w5, w1
    d900b590:	54ffff23 	b.cc	d900b574 <pwm_set_voltage+0xc>
    d900b594:	14000002 	b	d900b59c <pwm_set_voltage+0x34>
			break;
		}
	}
	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
		to = ARRAY_SIZE(pwm_voltage_table) - 1;
    d900b598:	52800383 	mov	w3, #0x1c                  	// #28
	}
	switch (id) {
    d900b59c:	7100041f 	cmp	w0, #0x1
    d900b5a0:	54000120 	b.eq	d900b5c4 <pwm_set_voltage+0x5c>
    d900b5a4:	71000c1f 	cmp	w0, #0x3
    d900b5a8:	540001c1 	b.ne	d900b5e0 <pwm_set_voltage+0x78>
	case pwm_b:
		P_PWM_PWM_B = pwm_voltage_table[to][0];
		break;

	case pwm_d:
		P_PWM_PWM_D = pwm_voltage_table[to][0];
    d900b5ac:	90000000 	adrp	x0, d900b000 <__BSS_SIZE__+0xd900b000>
    d900b5b0:	911d4000 	add	x0, x0, #0x750
    d900b5b4:	937d7c63 	sbfiz	x3, x3, #3, #32
    d900b5b8:	b8636801 	ldr	w1, [x0,x3]
    d900b5bc:	d290c880 	mov	x0, #0x8644                	// #34372
    d900b5c0:	14000006 	b	d900b5d8 <pwm_set_voltage+0x70>
	if (to >= ARRAY_SIZE(pwm_voltage_table)) {
		to = ARRAY_SIZE(pwm_voltage_table) - 1;
	}
	switch (id) {
	case pwm_b:
		P_PWM_PWM_B = pwm_voltage_table[to][0];
    d900b5c4:	90000000 	adrp	x0, d900b000 <__BSS_SIZE__+0xd900b000>
    d900b5c8:	911d4000 	add	x0, x0, #0x750
    d900b5cc:	937d7c63 	sbfiz	x3, x3, #3, #32
    d900b5d0:	b8636801 	ldr	w1, [x0,x3]
    d900b5d4:	d290aa80 	mov	x0, #0x8554                	// #34132
		break;

	case pwm_d:
		P_PWM_PWM_D = pwm_voltage_table[to][0];
    d900b5d8:	f2b82200 	movk	x0, #0xc110, lsl #16
    d900b5dc:	b9000001 	str	w1, [x0]
		break;
	default:
		break;
	}
	_udelay_(200);
    d900b5e0:	52801900 	mov	w0, #0xc8                  	// #200
    d900b5e4:	17ffff99 	b	d900b448 <_udelay_>

00000000d900b5e8 <power_init>:
}

void power_init(int mode)
{
    d900b5e8:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
    d900b5ec:	910003fd 	mov	x29, sp
	pwm_init(pwm_b);
    d900b5f0:	52800020 	mov	w0, #0x1                   	// #1
	}
	_udelay_(200);
}

void power_init(int mode)
{
    d900b5f4:	f9000bf3 	str	x19, [sp,#16]
	pwm_init(pwm_b);
    d900b5f8:	97ffff9e 	bl	d900b470 <pwm_init>
	pwm_init(pwm_d);
    d900b5fc:	52800060 	mov	w0, #0x3                   	// #3
    d900b600:	97ffff9c 	bl	d900b470 <pwm_init>
	serial_puts("set vcck to ");
    d900b604:	90000000 	adrp	x0, d900b000 <__BSS_SIZE__+0xd900b000>
    d900b608:	9120e000 	add	x0, x0, #0x838
    d900b60c:	9400002b 	bl	d900b6b8 <serial_puts>
	serial_put_dec(CONFIG_VCCK_INIT_VOLTAGE);
    d900b610:	d2808c00 	mov	x0, #0x460                 	// #1120
	serial_puts(" mv\n");
    d900b614:	90000013 	adrp	x19, d900b000 <__BSS_SIZE__+0xd900b000>
void power_init(int mode)
{
	pwm_init(pwm_b);
	pwm_init(pwm_d);
	serial_puts("set vcck to ");
	serial_put_dec(CONFIG_VCCK_INIT_VOLTAGE);
    d900b618:	94000034 	bl	d900b6e8 <serial_put_dec>
	serial_puts(" mv\n");
    d900b61c:	91211673 	add	x19, x19, #0x845
    d900b620:	aa1303e0 	mov	x0, x19
    d900b624:	94000025 	bl	d900b6b8 <serial_puts>
	pwm_set_voltage(pwm_d, CONFIG_VCCK_INIT_VOLTAGE);
    d900b628:	52808c01 	mov	w1, #0x460                 	// #1120
    d900b62c:	52800060 	mov	w0, #0x3                   	// #3
    d900b630:	97ffffce 	bl	d900b568 <pwm_set_voltage>
	serial_puts("set vddee to ");
    d900b634:	90000000 	adrp	x0, d900b000 <__BSS_SIZE__+0xd900b000>
    d900b638:	91212800 	add	x0, x0, #0x84a
    d900b63c:	9400001f 	bl	d900b6b8 <serial_puts>
	serial_put_dec(CONFIG_VDDEE_INIT_VOLTAGE);
    d900b640:	d2807d00 	mov	x0, #0x3e8                 	// #1000
    d900b644:	94000029 	bl	d900b6e8 <serial_put_dec>
	serial_puts(" mv\n");
    d900b648:	aa1303e0 	mov	x0, x19
    d900b64c:	9400001b 	bl	d900b6b8 <serial_puts>
	pwm_set_voltage(pwm_b, CONFIG_VDDEE_INIT_VOLTAGE);
}
    d900b650:	f9400bf3 	ldr	x19, [sp,#16]
    d900b654:	a8c27bfd 	ldp	x29, x30, [sp],#32
	serial_puts(" mv\n");
	pwm_set_voltage(pwm_d, CONFIG_VCCK_INIT_VOLTAGE);
	serial_puts("set vddee to ");
	serial_put_dec(CONFIG_VDDEE_INIT_VOLTAGE);
	serial_puts(" mv\n");
	pwm_set_voltage(pwm_b, CONFIG_VDDEE_INIT_VOLTAGE);
    d900b658:	52800020 	mov	w0, #0x1                   	// #1
    d900b65c:	52807d01 	mov	w1, #0x3e8                 	// #1000
    d900b660:	17ffffc2 	b	d900b568 <pwm_set_voltage>

00000000d900b664 <board_init>:
#include "power.c"

/* bl2 customer code */
void board_init(void)
{
	power_init(0);
    d900b664:	52800000 	mov	w0, #0x0                   	// #0
    d900b668:	17ffffe0 	b	d900b5e8 <power_init>

00000000d900b66c <bl21_main>:
#include "board_init.c"

void bl21_main(void)
{
	/* bl2 customer code */
	board_init();
    d900b66c:	17fffffe 	b	d900b664 <board_init>

00000000d900b670 <serial_putc>:
	    UART_CNTL_MASK_RST_TX | UART_CNTL_MASK_RST_RX | UART_CNTL_MASK_CLR_ERR);
}

int serial_putc(int c)
{
    if (c == '\n') {
    d900b670:	7100281f 	cmp	w0, #0xa
    d900b674:	54000121 	b.ne	d900b698 <serial_putc+0x28>
        while ((readl(P_UART_STATUS(UART_PORT_CONS)) & UART_STAT_MASK_TFIFO_FULL));
    d900b678:	d2809981 	mov	x1, #0x4cc                 	// #1228
    d900b67c:	f2b90201 	movk	x1, #0xc810, lsl #16
    d900b680:	b9400021 	ldr	w1, [x1]
    d900b684:	37afffa1 	tbnz	w1, #21, d900b678 <serial_putc+0x8>
        writel('\r', P_UART_WFIFO(UART_PORT_CONS));
    d900b688:	d2809801 	mov	x1, #0x4c0                 	// #1216
    d900b68c:	f2b90201 	movk	x1, #0xc810, lsl #16
    d900b690:	528001a2 	mov	w2, #0xd                   	// #13
    d900b694:	b9000022 	str	w2, [x1]
    }
    /* Wait till dataTx register is not full */
    while ((readl(P_UART_STATUS(UART_PORT_CONS)) & UART_STAT_MASK_TFIFO_FULL));
    d900b698:	d2809981 	mov	x1, #0x4cc                 	// #1228
    d900b69c:	f2b90201 	movk	x1, #0xc810, lsl #16
    d900b6a0:	b9400021 	ldr	w1, [x1]
    d900b6a4:	37afffa1 	tbnz	w1, #21, d900b698 <serial_putc+0x28>
    writel(c, P_UART_WFIFO(UART_PORT_CONS));
    d900b6a8:	d2809801 	mov	x1, #0x4c0                 	// #1216
    d900b6ac:	f2b90201 	movk	x1, #0xc810, lsl #16
    d900b6b0:	b9000020 	str	w0, [x1]
    /* Wait till dataTx register is empty */
    return c;
}
    d900b6b4:	d65f03c0 	ret

00000000d900b6b8 <serial_puts>:

    ch = readl(P_UART_RFIFO(UART_PORT_CONS)) & 0x00ff;
    return ((int)ch);
}

int serial_puts(const char *s){
    d900b6b8:	a9be7bfd 	stp	x29, x30, [sp,#-32]!
    d900b6bc:	910003fd 	mov	x29, sp
    d900b6c0:	f9000bf3 	str	x19, [sp,#16]
    d900b6c4:	aa0003f3 	mov	x19, x0
	while (*s) {
    d900b6c8:	39400260 	ldrb	w0, [x19]
    d900b6cc:	34000080 	cbz	w0, d900b6dc <serial_puts+0x24>
		serial_putc(*s++);
    d900b6d0:	91000673 	add	x19, x19, #0x1
    d900b6d4:	97ffffe7 	bl	d900b670 <serial_putc>
    d900b6d8:	17fffffc 	b	d900b6c8 <serial_puts+0x10>
	}
	return 0;
}
    d900b6dc:	f9400bf3 	ldr	x19, [sp,#16]
    d900b6e0:	a8c27bfd 	ldp	x29, x30, [sp],#32
    d900b6e4:	d65f03c0 	ret

00000000d900b6e8 <serial_put_dec>:
            serial_putc(0x61+s-10);
    }
}

void serial_put_dec(unsigned long data)
{
    d900b6e8:	a9bd7bfd 	stp	x29, x30, [sp,#-48]!
    d900b6ec:	910003fd 	mov	x29, sp
	char szTxt[10];
	szTxt[0] = 0x30;
    d900b6f0:	52800601 	mov	w1, #0x30                  	// #48
    d900b6f4:	390083a1 	strb	w1, [x29,#32]
            serial_putc(0x61+s-10);
    }
}

void serial_put_dec(unsigned long data)
{
    d900b6f8:	f9000bf3 	str	x19, [sp,#16]
	char szTxt[10];
	szTxt[0] = 0x30;
    d900b6fc:	d2800001 	mov	x1, #0x0                   	// #0
	int i = 0;

	do {
		szTxt[i++] = (data % 10) + 0x30;
    d900b700:	d2800143 	mov	x3, #0xa                   	// #10
    d900b704:	9ac30802 	udiv	x2, x0, x3
    d900b708:	9b038040 	msub	x0, x2, x3, x0
    d900b70c:	1100c000 	add	w0, w0, #0x30
    d900b710:	91008024 	add	x4, x1, #0x20
    d900b714:	383d6880 	strb	w0, [x4,x29]
    d900b718:	2a0103f3 	mov	w19, w1
		data = data / 10;
    d900b71c:	aa0203e0 	mov	x0, x2
    d900b720:	91000421 	add	x1, x1, #0x1
	} while(data);
    d900b724:	b5ffff02 	cbnz	x2, d900b704 <serial_put_dec+0x1c>

	for (--i;i >=0;--i)
		serial_putc(szTxt[i]);
    d900b728:	93407e61 	sxtw	x1, w19
    d900b72c:	910083a2 	add	x2, x29, #0x20
    d900b730:	38626820 	ldrb	w0, [x1,x2]
	do {
		szTxt[i++] = (data % 10) + 0x30;
		data = data / 10;
	} while(data);

	for (--i;i >=0;--i)
    d900b734:	51000673 	sub	w19, w19, #0x1
		serial_putc(szTxt[i]);
    d900b738:	97ffffce 	bl	d900b670 <serial_putc>
	do {
		szTxt[i++] = (data % 10) + 0x30;
		data = data / 10;
	} while(data);

	for (--i;i >=0;--i)
    d900b73c:	3100067f 	cmn	w19, #0x1
    d900b740:	54ffff41 	b.ne	d900b728 <serial_put_dec+0x40>
		serial_putc(szTxt[i]);
    d900b744:	f9400bf3 	ldr	x19, [sp,#16]
    d900b748:	a8c37bfd 	ldp	x29, x30, [sp],#48
    d900b74c:	d65f03c0 	ret

00000000d900b750 <pwm_voltage_table>:
    d900b750:	001c0000 0000035c 001b0001 00000366     ....\.......f...
    d900b760:	001a0002 00000370 00190003 0000037a     ....p.......z...
    d900b770:	00180004 00000384 00170005 0000038e     ................
    d900b780:	00160006 00000398 00150007 000003a2     ................
    d900b790:	00140008 000003ac 00130009 000003b6     ................
    d900b7a0:	0012000a 000003c0 0011000b 000003ca     ................
    d900b7b0:	0010000c 000003d4 000f000d 000003de     ................
    d900b7c0:	000e000e 000003e8 000d000f 000003f2     ................
    d900b7d0:	000c0010 000003fc 000b0011 00000406     ................
    d900b7e0:	000a0012 00000410 00090013 0000041a     ................
    d900b7f0:	00080014 00000424 00070015 0000042e     ....$...........
    d900b800:	00060016 00000438 00050017 00000442     ....8.......B...
    d900b810:	00040018 0000044c 00030019 00000456     ....L.......V...
    d900b820:	0002001a 00000460 0001001b 0000046a     ....`.......j...
    d900b830:	0000001c 00000474 20746573 6b636376     ....t...set vcck
    d900b840:	206f7420 766d2000 6573000a 64762074      to . mv..set vd
    d900b850:	20656564 00206f74                       dee to .
